// 1. 常量使用 const 关键字声明，且必须显式标注类型
// 2. 常量永远不可变，所以不能用 mut
// 3. 常量可以声明在任意作用域，包括全局作用域
// 4. 常量必须绑定到常量表达式，不能绑定到函数的调用结果或者运行时才能计算出的值
// 5. 程序运行期间，常量一直有效
// 6. 常量使用全大写，单词间用下划线隔开
const _SOME_CONSTANT: u32 = 100_000; // 数字可以插入下划线增强可读性

fn main() {
  // let 默认不可变，声明可变需要用 let mut
  // 下面两行代码会报错，因为 _x 是不可变的
  // let _x = 1;
  // _x = 2;

  // 变量声明时可以不初始化，但是变量必须初始化后才能正常使用
  // 下面两行会报错，因为 x1 未初始化就被使用了
  // let x1;
  // let x2 = x1;

  // Shaowing (隐藏)
  // 可以使用相同名称声明新变量，新的变量就会 shadow (隐藏) 之前声明的变量
  // Shadow 和把变量标记为 mut 不同：
  // 1. 不使用 mut 关键字，重新给非 mut 变量赋值会导致编译时错误
  // 2. 使用 Shadowing 声明的同名变量也是不可变的
  // 3. 使用 Shadowing 声明的新变量的类型可以与之前不同
  let spaces = "    ";
  let spaces = spaces.len();
  println!("spaces is {}", spaces);

  // Rust 是静态编程语言，需要在编译时知道所有变量的类型
  // 基于使用的值，编译器通常可以推断出它的具体类型
  // 但是如果可能的类型比较多，就必须显式地指明类型，否则编译会报错

  // 下面这段代码，如果你将 `: i32` 删掉，那么就会报错，因为 Rust 中有很多种类型
  // 可以表示 3 这个整数，比如 i32, u32 等，因此这时就需要显式指定类型
  let _three: i32 = "3".trim().parse().expect("Error!");

  // 标量类型
  // 4 种标量类型：整数类型、浮点类型、布尔类型和字符类型

  // 整数类型
  // 有符号 i 开头，无符号 u 开头，无符号整数都是非负的
  // -----------------------------
  //  length  | Signed | UnSigned
  // -----------------------------
  //  8-bit   | i8     | u8
  // -----------------------------
  //  16-bit  | i16    | u16
  // -----------------------------
  //  32-bit  | i32    | u32
  // -----------------------------
  //  64-bit  | i64    | u64
  // -----------------------------
  //  128-bit | i128   | u128
  // -----------------------------
  //  arch    | isize  | usize
  // -----------------------------
  // 有符号取值范围：[-(2^n-1), 2^(n-1)-1]，无符号取值范围：[0, 2^n-1]
  // arch 即 architecture，表示系统架构。比如 64 位计算机 isize 就是 i64, usize 就是

  // 整数字面值
  // --------------------------------
  //  Numbers literals | Example
  // --------------------------------
  //  Decimal          | 98_222
  // --------------------------------
  //  Hex              | 0xff
  // --------------------------------
  //  Octal            | 0o77
  // --------------------------------
  //  Binary           | 0b1111_0000
  // --------------------------------
  //  Byte (u8 only)   | b'A'
  // --------------------------------
  // 除了 Byte 类型外，所有的整数字面值都可以加类型后缀比如 57u8
  // 可以使用默认类型 i32，总体上 i32 速度很快，即使是在 64 位系统中

  // 整数溢出
  // u8 的范围为 [0, 255]，如果把一个 u8 类型的变量设为 256，那么：
  // 调试模式下，程序会 panic
  // 发布模式下，Rust 不会检查整数溢出，如果溢出发生，Rust 会执行“环绕”操
  // 作：256->0,257->1...，且程序不会 panic

  // 浮点类型
  // 浮点类型共有两种 f32，32 位单精度，f64，64 位双精度
  // Rust 使用 IEEE-754 标准来表述
  // 默认为 f64 类型

  // 基本运算
  // 加减乘除余
  let _sum = 5 + 10;
  let _difference = 95.5 - 4.3;
  let _product = 4 * 30;
  let _quotient = 56.7 / 32.2;
  let _reminder = 54 % 5;

  // 可以有 x+=1; 但没有 x++;
  let mut _some_number = 1;
  _some_number += 1;
  // _some_number++; // 报错

  // 布尔类型
  // 符号为 bool，一个字节大小

  // 字符类型
  // char 类型被用于描述语言中最基础的单个字符
  // 字符类型使用单引号
  // 占 4 个字节大小
  // 是 Unicode 标量值，可以表示比 ASCII 多得多的内容：拼音、中日韩文、零长
  // 度空白字符、emoji 表情等。范围为 [U+0000, U+D7FF] 和 [U+E000, U+10FFF]
  let _c = 'z';
  let _z: char = 'ℤ';
  let _heart_eyed_cat = '😻';

  // 复合类型
  // 复合类型可以将多个值放在一个类型中
  // Rust 提供了两种基础的复合类型：元组和数组

  // 元组 (Tuple)
  // 元组的长度是固定的，一旦声明就不能更改
  // 元组中的每个位置都对应一个类型，各元素类型不必相同
  let tup: (i32, char, bool) = (1, 'a', true);

  // 使用点标记法和索引来访问元组中的元素
  println!("elements in tup are {}, {}, {}", tup.0, tup.1, tup.2);

  // 数组
  // 数组长度是固定的
  // 数组中每个元素类型必须相同
  // 数组类型使用 [类型; 长度] 表示
  let _arr: [i32; 5] = [1, 2, 3, 4, 5];
  // 如果数组中的每个元素都相同，我们可以这样声明：
  let arr1 = [3; 5];
  // 这与 let arr1 = [3, 3, 3, 3, 3]; 等价

  // 使用中括号和索引来访问数组中的元素
  println!("first elemnt in arr1 is {}", arr1[0]);

  // 如果访问的索引超出了范围，那么编译会报错，但运行时程序会 panic

  // 函数
  // 使用 fn 关键字声明函数，函数名遵循 snake case 规范
  // 参数类型必须显式地指明
  fn _sum_fn(_x: i32, _y: i32) {
    // ...
  }

  // 函数体中的语句与表达式
  // 函数体由一系列语句组成，可选的由一个表达式结束
  // Rust 是一个基于表达式的语言
  // 语句是执行一些动作的指令
  // 表达式会产生一个值
  // 变量声明，函数声明都是语句
  // 语句不返回值，不能使用 let 将语句赋值给变量

  // 下面这行会报错
  // let _x = (let y = 1);

  // 块表达式的值为最后一行表达式的值
  let _y = {
    let x = 1;
    x + 5 // 如果这里加上 ;，那么它就变为了语句，_y 的类型变为空元组 ()
  };

  // 函数返回值
  // 可以使用 -> 为返回值声明类型
  // 返回值是函数体中最后一个表达式的值
  // 可以使用 return 关键字提前返回
  fn _plus_5(x: i32) -> i32 {
    if x == 0 {
      return 5;
    }
    x + 5
  }

  // if 表达式
  // if 表达式中的条件必须是 bool 类型
  // 可以使用 if 表达式赋值，但是每个分支返回的类型必须相同
  let _if_var = if 5 > 1 { 66 } else { 77 };

  // loop 循环
  // loop 中可以使用 continue, break，就和其他语言一样
  // break 后面如果跟着表达式，就将其视为 loop 循环返回的值，由此可以看出 loop 循环
  // 也是一个表达式
  let mut loop_count: i32 = 0;
  let _loop_var: i32 = loop {
    loop_count += 1;
    if loop_count == 10 {
      break loop_count * 5;
    }
  };

  // while 循环
  // while 循环不能使用 break 跟表达式的语法，否则会报错
  // while 循环也是表达式，返回空元组 ()
  let mut while_condition = 10;
  let _while_loop_value = while while_condition > 0 {
    while_condition -= 2;
  };

  // for 循环
  // 一般用于遍历集合
  let for_loop_arr = [1, 2, 3, 4, 5];
  for element in for_loop_arr.iter() {
    println!("element is {}", element); // 1 2 3 4 5
  }

  // Range
  // 标准库提供
  // 指定开始数字和结束数字，Range 可以生成它们之间的数字，左闭右开区间
  // rev() 方法可以反转
  for number in (0..5).rev() {
    println!("number is {}", number); // 4 3 2 1 0
  }
}
