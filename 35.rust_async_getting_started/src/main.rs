// 其他并发模型
//
// * OS 线程：
//   - 无需改变编程模型，线程间同步难度大，性能开销大。
//   - 线程池可以节省一些成本，但难以支撑大量 IO 绑定的操作。
// * 事件驱动：
//   - 与回调函数一起使用，可能比较高效。
//   - 非线性的控制流，数据流和错误传播难以追踪。
// * Coroutines：
//   - 类似线程，无需改变编程模型。
//   - 类似 async，支持大量任务。
//   - 抽象掉了底层细节（这对于系统编程，自定义运行时很重要）。
// * Actor：
//   - 将所有并发计算划分为 actor，消息通信易出错。
//   - 可以有效地实现比较高效地 actor 模型，但许多实际问题没有解决（控制流，重试逻辑）。

// Rust 中的异步与多线程
//
// * OS 线程：
//   - 适用于少量任务，有内存与 CPU 开销，且线程生成的线程间切换非常昂贵。
//   - 线程池可以降低一些成本。
//   - 允许重用同步代码，代码无需大改，无需特定编程模型。
//   - 有些系统支持修改线程优先级。
// * 异步：
//   - 显著降低内存和 CPU 开销。
//   - 同等条件下，支持比线程多几个数量级的任务（少数线程支撑大量任务）。
//   - 可执行文件大（需要生成状态机，每个可执行文件捆绑一个异步运行时）。

// 异步编程不一定比多线程要好，只是适用场景不完全一样而已。

// Rust Async 现状
//
// * 大部分特性稳定，部分特性仍在变化。
// * 特点：
//   - 针对典型并发场景，性能出色。
//   - 与高级语言特性频繁交互（生命周期、pinning 等）。
//   - 同步和异步代码间、不同运行时的异步代码间存在兼容性约束。
//   - 由于部分特性不稳定，所以可能维护成本略高。

// 语言和库的支持
//
// * Rust 本身支持异步编程，但是很多应用依赖于社区提供的库：
//   - 标准库提供了最基本的特性类型和功能，比如 Future trait。
//   - Rust 编译器直接支持 async/await 语法。
//   - futures crate 提供了许多适用类型、宏和函数。它们可以用于任何异步应用程序代码。
//   - 异步代码、IO 和任务生成的执行依赖于异步运行时，大多来自社区。比如 tokio 和 async-std。

// 注意！Rust 不允许在 trait 中声明 async 函数（使用 async-trait crate 可以）。

// 编译与调试
//
// * 编译错误：
//   - 由于异步编程通常依赖于更加复杂的语言功能，例如生命周期和 pinning，因此可能会更加频繁地
//     遇到这些类型的错误。
// * 运行时错误：
//   - 每当运行时遇到异步函数，编译器会在后台生成一个状态机，Stack traces 中有其明细，以及运行
//     时调用的函数。因此解释起来更加复杂。
// * 新的失效模式：
//   - 可能出现一些新的故障，这些故障能通过编译，甚至单元测试，但运行时则会出现问题。

// 兼容性考虑
//
// * 异步代码和同步代码不能总是自由组合，比如不能直接从同步函数来调用。
// * 异步代码间也不总是能自由组合，一些 crate 依赖于特定的异步运行时。
// 所以，尽早确定需要使用的异步运行时。

// 性能
//
// 异步代码的性能也依赖于异步运行时（通常性能都很高）。

// async
//
// * async 把一段代码转换为实现了 Future trait 的状态机。
// * 虽然在同步方法中调用阻塞函数会阻塞整个线程，但阻塞的 Future 将放弃对线程的控制，从而
//   允许其他 Future 的运行。

// async 函数
//
// * async 函数返回的是一个 Future，Future 需要一个执行者来执行。
// * futures::executor::block_on：
//   - block_on 会阻塞当前线程，直到 Future 执行完成。
//   - 其他的执行者提供更复杂的行为，比如将多个 Future 安排到同一线程上。

use futures::{self, executor::block_on};

// Future 是惰性的，需要一个执行者来运行
async fn hello_world() {
  println!("async hello world");
}

fn run_future() {
  let future = hello_world(); // 这里不会打印
  block_on(future); // 使用 block_on 执行，它会阻塞当前线程直到 Future 完成
}

// await
//
// * 也可以使用 .await 来等待一个 Future 的完成。
// * 与 block_on 不同，使用 .await 不会阻塞当前线程，而是异步地等待其完成。

struct Song {}

async fn learn_song() -> Song {
  Song {}
}

async fn sing(_: Song) {}
async fn dance() {}

async fn learn_and_sing() {
  let song = learn_song().await;
  sing(song).await;
}

// 异步地唱歌和跳舞
async fn sing_and_dance() {
  let f1 = learn_and_sing();
  let f2 = dance();
  futures::join!(f1, f2);
}

fn main() {
  run_future();
  block_on(sing_and_dance());
}
