// 生命周期
// Rust 中的每个引用都有自己的生命周期，它可以保证引用的有效性，避免悬垂引用
// 大多数情况，生命周期是隐式的，编译器可以自行推断
// 当引用的生命周期可能以不同的方式相互关联时，需要手动标注清楚

// Rust 中使用借用检查器比较借用值的生命周期来确保引用的合法性

// 生命周期标注
// 语法：
// 1. 以 ' 开头
// 2. 一般全小写，并且比较短
// 3. 习惯性使用 a，类似泛型习惯使用 T
// 例子：
// &i32         i32 引用
// &'a i32      带有显式生命周期的 i32 类型的引用
// &'a mut i32  带有显式生命周期的 i32 类型的可变引用
// 声明周期标注主要描述了多个引用的生命周期的关系，不会改变生命周期

// 泛型生命周期参数
// s1, s2 和返回值拥有同样的声明类型
// 生命周期在函数/方法的参数：输入生命周期
// 生命周期在函数/方法的返回值：输出生命周期
fn longest<'a>(s1: &'a str, s2: &'a str) -> &'a str {
  if s1.len() > s2.len() {
    s1
  } else {
    s2
  }
}

// 为结构体添加生命周期标注
struct _Message<'a> {
  content: &'a str,
}

// 实现方法
impl<'a> _Message<'a> {
  fn _show_content(&self) -> &str {
    self.content
  }
}

// 生命周期省略的三个规则
// 1. 每个引用类型参数都有自己的生命周期
// 2. 如果只有 1 个输入生命周期参数，那么该生命周期被赋给所有的输出生命周期参数
// 3. 如果有多个生命周期参数，但其中一个是 &self 或 &mut self，那么 self 的生命周期
// 会被赋给所有的输出生命周期参数
// 如果编译器应用三个规则后，仍然有无法确定生命周期的引用，就会报错
// 适用于 fn 定义和 impl 块

fn main() {
  // let x;
  // {
  //   let y = 5;
  //   // 报错！y 生命周期短于 x
  //   x = &y;
  // }

  // println!("{}", x);

  let s1 = String::from("s1");
  let result;
  {
    let s2 = "s2";
    result = longest(s1.as_str(), s2);
  }
  println!("{}", result);

  // 静态生命周期
  // 'static 是一种特殊的生命周期，整个程序的持续时间
  // 所有的字符串字面值都拥有 'static 生命周期
  let _str: &'static str = "some text";
  // 为引用指定 'static 生命周期前需三思
  // 是否需要引用在程序整个生命周期都存活
}

// 同时使用泛型，trait bound，生命周期
// 生命周期参数要放在泛型参数前
fn _some_fn<'a, 'b, T>(item1: &'a String, item2: &'b T) -> &'a String
where
  T: std::fmt::Display,
{
  println!("{}", item2);
  item1
}
